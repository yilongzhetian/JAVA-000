# 总结
很荣幸能够参加秦老师的训练营课程，能够和诸多小伙伴们一同学习，平时工作中对老师所讲的内容都略有接触，但是都是浅尝辄止，秦老师的课程即有广度又有深度，能够将知识点串联起来比较，使我非常受益匪浅，师傅领进门，修行在个人，虽然课程结束，但是学习依然需要继续，老师的课程还需要持续消化，另外通过本次学习，意识到自己最大的一个缺点是不擅长总结，导致学的快忘得快，之后一定要加强这方面的锻炼，最后再借用秦老师之前一直说的一句话靡不有初,鲜克有终来勉励自己，继续前行。

# JVM
1. JVM(java虚拟机)属于一种规范，常用的是有sun实现的hotspot虚拟机，属于栈虚拟机，我们编写的类经过javac编译成字节码，然后交由虚拟机处理，经过加载->连接（验证->准备->解析）->初始化->使用->卸载完成其整个生命周期，jvm的类加载器有三种启动类加载器->扩展类加载器->系统类加载器，加载类时一直找到其最顶端的父类，然后开始往下进行一层一层寻找，我们自己可自定义类加载器，一般属于用户类加载器范畴，我们可以通过ByteBuddy或者asm进行单独的字节码操作
2. jvm的内存模型分为栈/堆/非堆/对外内存，jvm自带垃圾回收器，主要针对的事堆内存，常用的垃圾回收算法引用计数/标记清除/标记复制/标记清除整理等算法，常用的垃圾回收器有串行GC/并行GC/CMS/G1,jdk8默认的GC算法是并行GC，
优点：新生代和老年代都可以适用并行的多线程进行回收，执行时，所有线程均用于垃圾回收，回收完之后至下次gc时，只有工作线程运行，因此吞吐量会比较高 缺点：堆内存过高时，会造成gc停顿时间过长


# NIO
1. 网络通讯模式分为同步和异步，线程处理模式为阻塞和非阻塞。
常用的IO模型从最初的同步阻塞IO->同步非阻塞IO->IO多路复用->信号驱动IO-异步IO。现阶段常用的为IO模型为IO多路复用也称事件驱动 IO，在单个线程里同时监控多个套接字，通过select或poll轮询所负责的所有socket，当某个socket有数据时才通知用户进程。
 其中select/poll模型，需要有操作系统支持，缺点fd集合从用户态copy到内核态，fd需要遍历，fd默认为1024，到后来linux2.6以后的epoll模型修正了以上确定，具体是fd用户态和内核共享，回调解决遍历，fd没有限制。
2. 高性能网络通信框架netty，异步，事件驱动，基于NIO，netty最要的概念BECH,分别为Bootstrap/EventLoopGroup/Channel/Handler,netty的优势是在几乎能把每阶段能用多线程的全部都改用了线程池处理

# 并发编程
并发的本质是解决多个线程对同一资源争用的问题，线程是操作系统执行的最小单位，线程有自己的运行时状态，线程在JVM中有单独自己的栈空间，但是共享堆空间，对象分配在堆空间中，对象的成员变量也在堆空间中，方法中的局部变量属于线程私有，不存在竞争，但是对象的成员变量在堆空间中，因此存在竞争关系，解决竞争关系一般使用锁，同一时刻只允许一个线程操作，保证数据的准确性，java一般提供synchronized和lock进行线程间同步，同时提供了基础类型的原子类，线程安全的集合类方便我们操作，针对线程间的通信，除了原始的wait，notify，还提供了计数，信号量，循环计数等常用通信机制，针对多线程，提供了线程池来进行统一管理。



# Spring和ORM等框架
1. spring是java后端各种框架的集大成者，通过ioc容器将各种bean纳入进行统一管理，通过aop技术对各种bean进行增强处理，其中包括自身携带的事务管理器，使用springMVC对web提供了支持，由于对bean进行统一托管的机制，使得其很好集成了各类框架（消息中间件/orm/webservices/nosql等），同时spring在构建初始化bean时，开放了许多扩展点，使得开发者可以在bean的初始化前后加入自己的定制逻辑，由于spring对注解的支持和扩展，使得springboot迅速发展起来，自动配置的功能，使其达到开箱即用的水准，spring-boot-starter机制的引入，使得开发更加容易，后续的springcloud相关组件都建立在springboot基础上
2. orm框架(对象关系映射),目前常用的是hibernate和mybatis，hibernate将sql高度封装，不需要手动写sql，开发简单，面向对象，但是由于sql不受控制，所以出问题排查起来也不好排查，mybatis把写sql的权利交给了开发人员，尤其写复杂sql时更容易受控，属于半orm框架，另外目前都有成熟的框架mybatis-plus等帮助我们自动生成一些常用sql操作，我们再根据生成的自行做些修改适配我们的逻辑，也很方便，另外hibernate和mybatis都有自己的缓存机制，也可集成三方缓存框架。



# Mysql数据库和SQL
数据库产品有很多，常用的为mysql，为关系型数据库，mysql的默认存储引擎为innodb，具备事务性，事务分为原子性/一致性/隔离性/持久性，原子性指的是同一事物内的语句要么全部成功，要么全部失败。隔离性有四种级别为/只读/读已提交/可重复读/串行读，每一种隔离级别约来越严格，性能越来越差，mysql默认隔离级别为读已提交。mysql中的锁分为表锁/行锁/间隙锁，注意死锁的情况，发生死锁的话，只有一种办法，将形成的环强行断开，主要要想走行锁，查询条件必须要带有索引的行，否则极有可能退化成表锁，间隙锁只存在插入情况，需要锁住行与行之间的范围，防止出现幻读，这个也很容易出现行锁。mysql的binlog存储注意格式statement/row/mixed的却别，编写sql语句时要注意不要出现大事务，要想办法走索引，删除大量数据时注意分批删，mysql的索引使用的是B+树，注意与B树的区别，这种结构天然有序。mysql本身支持主从复制，配置简单，需要注意主从延时问题，mysql本身不支持高可用，主从无法自动切换，需要配合其他组件实现自动切换


# 分库分表
1. 分库分表使用的场景是当数据量过大单表查询过慢，就要通过分库分表来解决，在一个数据库实例中进行分库分表与在一个库中将表分成多个实际作用并不大，数据量并未减少，内存磁盘都是共用的，优势不明显，所以正确的方式是将单表按照一定字段规则分布到不同的数据库中（在不通机器上），才能体现优势，shardingsphere作为中间件可以代替该分库分表工作，如果只是单表查询还好，如果牵扯到表关联，需要权衡，尽量将关联的表分布到同一台机器同一个库中，否则性能会比较低，
2. 分库分表可以解决单表数据量大查询慢的问题，优势很明显，但是同样有缺点：
 数据迁移问题（shardingsphere提供有方案）
 维护问题（dml等操作），可以通过sharding-proxy方式解决，但是如果拆分后的表属于热点表，都需要特别注意了
 不适用复杂查询等操作

# RPC和微服务
目前存在主流的两种架构是单体架构和微服务架构，单体架构适合访问量不多，业务简单的场景，测试部署都很方便，
微服务架构适合大规模系统下，服务间相互协调对外提供一致服务情况，微服务实施过程中要解决服务相互隔离，但又可以进行相互通信，服务注册和发现，服务的熔断和限流等问题。微服务每种功能都有对应很多开源组件来提供支撑，服务间的通信常使用rpc调用，有dubbo/http/grpc等框架支持，服务的注册发现一般有zookeeper/eureka/nacos/etcd等框架支持，限流降级框架一般有
Hystrix/Sentinel等，业务网关一般有springcloud-gateway/soul支持，所有的组件都可以自由组合，在采取选型的因为可选组件太多，就会带来一定麻烦，微服务的好处是按业务单独拆分后，可以相互独立开发上线互不影响，对访问频繁的服务可以按需扩容，对有问题的服务可以隔离熔断而不影响整体平台稳定性，但同时也会带来运维部署麻烦，好在现在都有自动化测试部署工具。微服务的拆分需要按业务进行合理拆分，过大过小都容易引起问题。


# 分布式缓存
缓存主要解决的问题是对相同结果产生大量读请求时，数据库层面资源有限，需要缓存来分担流量。经过复杂计算后产生的结果利用缓存提升性能效果是很明显的。缓存分为本地缓存和集中式缓存，本地缓存列如常用的hashmap等都可以充当，另外ehcache和guava cache也都属于本地缓存框架，优势很明显，在同一jvm内，没有网络消耗，直接调用将结果返回，但是对于集群应用模式下，具有状态的缓存列如session共享，无法通过本地缓存做到全局共享，此时就需要集中式缓存，有memcache和redis，代表是redis，支持主从模式，支持哨兵模式（高可用），支持集群分片模式（缓存数据量大），但是同时也要注意缓存雪崩问题（大量key同时失效，可使用随机设定过期时间避免），缓存穿透问题（持续访问不存在的key，使用布隆哈希过滤等解决），缓存击穿问题（热点key失效，需要合理设置过期策略或手动维护），redis处理数据部分属于单线程，谨慎使用范围查询，bigkey等长时阻塞redis的操作。
# 分布式消息队列
消息队列主要解决的问题是业务解耦/异步执行/削峰填谷,其本质也可以看做是一个简化版的数据库，作为生产者和消费者之间的一个缓冲带，平衡两者生产和消费速度，消息队列一般有点对点模式和主题订阅模式，消息队列的实现上有多种协议规范AMQP/MQTT/STOMP/JMS等，JMS是java领域的消息服务规范，缺点是只支持java语言。常用的消息队列中间件有ActiveMQ/RabbitMQ(一代mq)，kafka/RocketMq(二代mq)，一代mq中，都是基于内存的，不善于吞吐量大的场景。在二代mq中，一个明显的优势是，吞吐量增强，主要使用了分区及磁盘顺序读写技术特性来提升吞吐量及性能，分区的特性使得同一个消息主题可以分布在不通的机器不通的分区中，此举有两个作用，分区多副本解决可用行问题以及客户端可以对接到不同的分区，加快生产或消费速度，不同分区不会产生竞争。另外一个功能特性就是磁盘顺序读写，这个特性使得mq可以充分利用磁盘容量大的特点，存储更多的消息。
