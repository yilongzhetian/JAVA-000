# 垃圾收集器分析
## 优缺点及适用场景
### 串行GC
优点：实现简单，堆内存小的时候有比较好的性能
缺点：只能适用单核cpu，堆内存增大时，full gc时间过长
### 并行GC
优点：新生代和老年代都可以适用并行的多线程进行回收，执行时，所有线程均用于垃圾回收，回收完之后至下次gc时，只有工作线程运行，因此吞吐量会比较高
缺点：堆内存过高时，会造成gc停顿时间过长
### CMS
优点：针对老年代将gc回收细节进行拆分，只使用少量的线程进行多个步骤并发回收垃圾，期间工作线程仍然运行，适合响应优先的场景
缺点：垃圾回收算法过于复杂，不适合堆内存过高的场景
### G1
优点：将内存拆分成n块大小一致的堆空间，gc回收线程一直在后台进行清理工作，每次清理一部分空间，将原先整个gc的清理耗时分摊到每次gc中，稍大一些内存使用会有优势，适合响应优先场景
缺点：晋升失败或并发标记失败可能导致退化成串行gc收集，造成停顿时间过长，另外不适合超大堆内存
## 示例分析

| GC算法 | 512m  | 1024m  | 2048m |4096m|
|------|---|---|---|---|
|  -XX:+UseSerialGC|   11868   |  14490  | 12624  |10240|
|  -XX:+UseParallelGC| 10857 | 16555  |  15590  | 13584  |
|  -XX:+UseConcMarkSweepGC| 11659  |15051   |  13886  | 12356  |
|  -XX:+UseG1GC| 11038  | 13504  |  13726  | 12646  |


## 总结
1. 在较小堆内存下如512m，四种垃圾回收算法吞吐量相差不大
2. 当内存超过1024m，小于4096m时，并行gc相对于其他gc吞吐量有所提升
3. 串行gc随着内存增大，吞吐量下降，gc暂停时间过长
4. G1GC在内存小于4096m时，吞吐量优势不明显
5. 随着内存增大，串行和并行gc的full gc暂停时长会增大，cms和G1GC由于拆分成n阶段，并部分步骤使用了并发gc，暂停时长相对较小